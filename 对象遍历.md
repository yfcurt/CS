# 对象遍历

可能有些同学听过在 JavaScript 中遍历对象顺序不固定的这一说法。事实上，这个说法不是特别准确。
对待遍历顺序，对象有一套自己既定的规则，在此规则下呢，对象的遍历顺序会受插入元素顺序的影响，但是不完全受插入元素先后顺序的影响。如果您有「必须按插入元素顺序遍历」的场景，可以考虑使用 Map。

遍历对象的方法有很多种，我们经常会使用的有：
- `for...in`
- `Object.keys`
- `Object.entries`
- `Obejct.getOwnerProPertyNames`
- `Reflect.ownKeys`
- ......

上面我们列的几个方法，都按照一样的规则去遍历对象。而实际的遍历规则会根据 key 值类型的不同而不同。

## 00. 从规范中定义的算法说起
在ES6之前，一个对象属性（键）的列出顺序依赖于浏览器的具体实现，并未在规范中定义。  
多数引擎采用的是按照 **创建顺序** 进行枚举。

**ES6** 规范新增了一些算法的定义，来规范对象属性的列出顺序。包括：
- [[OwnPropertykeys]]
- [[Enumerate]]（于 ES2016/ES7 废除），变更为抽象方法 `EnumerateObjectProperties`

## 01. [[OwnPropertykeys]]
### 1.1 列出属性的范围
这个算法会产生对象的 **所有实例属性** （即自身拥有的，而非继承来的）
- 包括 **字符串属性** 和 **Symbol符号属性**
- 无论是否可枚举

### 1.2 使用该算法的方法
- `Reflect.ownKeys(..)`
  - 返回由 目标对象 自身的属性键 组成的数组
  - 相当于 `Object.getOwnPropertyNames()` 与 `Object.getOwnPropertySymbols()` 得到的两个数组进行拼接。
- `Object.getOwnPropertyNames(..)`
  - 返回由 目标对象 自身的字符串属性键 组成的数组
- `Object.getOwnPropertySymbols(..)`
  - 返回由 目标对象 自身的Symbol属性键 组成的数据
- `Object.assgin(target, ...sources)`
  - 将所有 可枚举的自身的属性 从 一个或多个源对象 复制到 目标对象，返回修改后的对象。
  - 其中对于每一个源对象，都是用 `[[ownPropertyKeys]]`算法枚举（列出）其属性键，并过滤出可枚举的属性。

在一个对象中，如果我们的 key 值是像 '1'、'200'这种正整数格式的字符串。 遍历的顺序是按照 key 值的大小来排列的。

例如：
```js
const obj = {}

obj['4'] = 'a'
obj['3'] = 'b'
obj[2] = 'c'
obj[1] = 'd'

console.log(Object.keys(obj)) //  ['1', '2', '3', '4']
```
我们最后的遍历顺序完全忽视了插入顺序，并且，值得我们注意的是，在对象中，就算我们添加属性时的索引值是 Number 类型，最后的结果还是会被隐式的转为字符串。

数组作为对象的一种，也符合上面的规则，又或许，有上面的表现就是因为要兼容数组的缘故呢。除此之外，通过上面的规则，我们还可以推断出，对类数组（key 值是正整数且有 length 属性）进行遍历也是按照索引顺序的。

另外，如果我们的 key 值是不能转为正整数的字符串，这其中包括了可以转换为负数的字符串（ 如 '-1' ）、小数格式的字符串(如 '1.0' ) 和其他的字符串。他们的遍历顺序会比较符合直觉，就是插入对象的顺序：
```js
const obj2 = {}

obj2['1.1'] = 'a'
obj2['1.0'] = 'b'
obj2['-1'] = 'c'
obj2['jack'] = 'd'
obj2['09'] = 'e'
obj2['08'] = 'f'

console.log(Object.keys(obj2)) //  ['1.1', '1.0', '-1', 'jack', '09', '08']
```

事实上，对象的索引值的类型不仅可以是字符串，还可以是 Symbol 类型。对于 Symbol 类型而言，它的遍历顺序也是单纯的按照插入对象的顺序。

如果我们的对象综合了上面所有的情况，即一个对象的索引值出现了所有的类型（各种形式的字符串、Symbol 类型），它会：
1. 先按照我们上面提的关于正整数的规则遍历正整数部分
2. 按接下来会插入顺序遍历剩下的字符串
3. 最后再按照插入顺序遍历 Symbol 类型

```js
const obj2 = {}
const syb1 = Symbol()
const syb2 = Symbol()

obj2['1.1'] = '1.1'
obj2['1.0'] = '1.0'
obj2['7'] = '7'
obj2['6'] = '6'
obj2['-1'] = '-1'
obj2['jack'] = 'jack'
obj2[syb1] = 'syb1'
obj2['09'] = '09'
obj2['08'] = '08'
obj2[syb2] = 'syb2'

console.log(Object.keys(obj2)) //  ['6', '7', '1.1', '1.0', '-1', 'jack', '09', '08']
```
Symbol定义的属性不会出现在下面循环中：
- `for in`：可获取原型属性，不可获取不可枚举属性
- `for of`：不可遍历对象，可遍历数组
- `Object.keys`：原型属性和不可枚举属性都不能获取
- `Object.getOwnPropertyByNames`：不可获取原型属性，可获取不可枚举属性
- `JSON.stringify`：原型属性和不可枚举属性都不能获取
- `Reflect.ownKeys`：可获取不可枚举和Symbol，不可获取原型

- 获取原型上属性的有：`for in`;
- 获取不可枚举属性的有：getOwnPropertyNames, Reflect.ownKeys
- 可获取Symbol属性的有：getOwnPropertySymbol, Reflect.ownKeys

相信到这里，大家已经完全明白了对象的遍历顺序问题，最后还有一点值得大家注意的点，是 for...in 的遍历顺序问题。

最开始的时候，for...in 的遍历顺序并没有一个统一的标准，浏览器厂商会按照他们的喜好去设置 for...in 的遍历顺序。如果您对遍历顺序有要求并且要兼容老的浏览器版本，建议不使用它。后来 ES 2019 的 一个提案 对此现象进行了规范，现在 for...in 的顺序也遵循上面的规则。

尽管会遵循上面的规则，但是 for...in 还会遍历原型的属性。所以 for...in 的变量元素的规则是先按照我们上面讲的对象遍历规则去变量对象本身，接下来再按照此规则去遍历对象的原型，以此类推，直到遍历到顶部。
